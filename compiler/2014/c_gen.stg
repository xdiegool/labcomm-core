program(decls) ::= <<
#include "labcomm.h"
#include "labcomm_private.h"
#include "minimal.h" //TODO: send lcName

//TODO gen dependency signatures

$decls:{d | $processDecl(d)$};separator="\n\n"$
>>

processDecl(decl) ::= <<
//$decl.Name$
$if(decl.SampleDecl)$$processSampleDecl(decl)$$else$processTypeDecl(decl)$endif$
>>

dispatch(TMPL, obj, name, data) ::= <<
$([TMPL,obj.TemplateType])(obj,name, data)$
>>

processSampleDecl(decl) ::= <<
static int sizeof_minimal_$decl.Name$(void *vv) //TODO: send lcName
{
  int result = 0;
  result += 32 //TODO: calc size;
  return result;
}

static struct labcomm_signature signature_minimal_$decl.Name$ = {
  "$decl.Name$",
  sizeof_minimal_$decl.Name$,
  sizeof(signature_bytes_minimal_$decl.Name$),
  signature_bytes_minimal_$decl.Name$,
  0,
  sizeof(signature_tree_minimal_$decl.Name$),
  signature_tree_minimal_$decl.Name$
 };

const struct labcomm_signature *labcomm_signature_minimal_$decl.Name$ = &signature_minimal_$decl.Name$;

static void decode_minimal_$decl.Name$(
  struct labcomm_reader *r,
  void (*handle)(
    minimal_$decl.Name$ *v,
    void *context
  ),
  void *context
)
{
  minimal_$decl.Name$ v;
  $dispatch("C_DECODE_", decl.Type, decl.Name, "v")$
  handle(&v, context);
}

int labcomm_decoder_register_minimal_$decl.Name$(
  struct labcomm_decoder *d,
  void (*handler)(
    minimal_$decl.Name$ *v,
    void *context
  ),
  void *context
)
{
  return labcomm_internal_decoder_register(
    d,
    &signature_minimal_$decl.Name$,
    (labcomm_decoder_function)decode_minimal_$decl.Name$,
    (labcomm_handler_function)handler,
    context
  );
}
int labcomm_decoder_ioctl_minimal_$decl.Name$(
  struct labcomm_decoder *d,
  int ioctl_action,
  ...
)
{
  int result;
  va_list va;
  va_start(va, ioctl_action);
  result = labcomm_internal_decoder_ioctl(
    d, &signature_minimal_$decl.Name$, 
    ioctl_action, va);
  va_end(va);
  return result;
}

static int encode_minimal_$decl.Name$(
  struct labcomm_writer *w
  , minimal_$decl.Name$ *v
)
{
  int result = 0;
  $dispatch("C_ENCODE_", decl.Type, decl.Name, "(*v)")$

  return result;
}
>>

processTypeDecl(decl) ::= <<
   //TYPE_DECL $decl.Name$
   $dispatch("C_DECODE_", decl.Type, decl.Name, "TYPEDECL???")$

>>

C_DECODE_PrimType(obj, name, path) ::= <<
$path$ = labcomm_read_$obj.TypeName$(r);
>>

C_DECODE_UserType(obj, name, path) ::= <<
$dispatch("C_DECODE_", obj.TypeDecl, name, path)$
>>

C_DECODE_VoidType(obj, name, path) ::= <<
// ERROR: decode VoidType
>>

C_DECODE_StructType(obj, name, path) ::= <<
$obj.TTFields:{f |$dispatch("C_DECODE_", f , f.Name, [path,".", f.Name])$};separator=",\n"$
>>

//Field ignores the name parameter, and uses obj.name
C_DECODE_Field(obj, name, path) ::= <<
$dispatch("C_DECODE_", obj.Type, obj.Name, path)$
>>

C_DECODE_ArrayType(obj, name, path) ::= <<
//C_DECODE_ARRAY $obj.TypeName$ $name$$obj.ArrayDims:{d | [$d.TTString$]}$
>>

C_DECODE_TypeDecl(obj, name, path) ::= <<
$dispatch("C_DECODE_", obj.Type, obj.name, path)$
>>


C_ENCODE_PrimType(obj, name, path) ::= <<
result = labcomm_write_int(w, $path$);
if (result != 0) { return result; }
>>

C_ENCODE_UserType(obj, name, path) ::= <<
$dispatch("C_ENCODE_", obj.TypeDecl, name, path)$
>>

C_ENCODE_VoidType(obj, name, path) ::= <<
// ERROR: decode VoidType
>>

C_ENCODE_StructType(obj, name, path) ::= <<
$obj.TTFields:{f |$dispatch("C_ENCODE_", f , f.Name, [path,".", f.Name])$};separator=",\n"$
>>

//Field ignores the name parameter, and uses obj.name
C_ENCODE_Field(obj, name, path) ::= <<
$dispatch("C_ENCODE_", obj.Type, obj.Name, path)$
>>

C_ENCODE_ArrayType(obj, name, path) ::= <<
//C_ENCODE_ARRAY $obj.TypeName$ $name$$obj.ArrayDims:{d | [$d.TTString$]}$
>>

C_ENCODE_TypeDecl(obj, name, path) ::= <<
$dispatch("C_ENCODE_", obj.Type, obj.name, path)$
>>
