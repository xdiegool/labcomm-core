program(decls) ::= <<
program {
    $decls:{d | $declSig(d)$};separator="\n\n"$
};
>>

declSig(decl) ::= <<
//$decl.Name$
$if(decl.SampleDecl)$$sampleSig(decl)$$else$//Typedefs have no static signature$endif$
>>

dispatch(TMPL, obj, name) ::= <<
$([TMPL,obj.TemplateType])(obj,name)$
>>

sampleSig(decl) ::= <<
  private static byte[] signature = new byte[] {
   $dispatch("JAVA_SIG_", decl.Type, decl.Name)$
  }; 
>>

EncodeString(str) ::=  <<
$length(str.Bytes)$, $str.Bytes;separator=", "$
>>

JAVA_SIG_PrimType(obj, name) ::= <<
// $obj.TypeName$ 
$obj.Token$ 
>>

JAVA_SIG_UserType(obj, name) ::= <<
$dispatch("JAVA_SIG_", obj.TypeDecl, name)$
>>

JAVA_SIG_VoidType(obj, name) ::= <<
// void 
17, 0
>>

JAVA_SIG_StructType(obj, name) ::= <<
// struct $length(obj.TTFields)$ fields {
  17, $length(obj.TTFields)$,
  $obj.TTFields:{f |$dispatch("JAVA_SIG_", f, f.Name)$};separator=",\n"$
//} 
>>

//Field ignores the name parameter, and uses obj.name
JAVA_SIG_Field(obj, name) ::= <<
//$obj.TypeName$ $obj.Name$
$EncodeString(name)$,
$dispatch("JAVA_SIG_", obj.Type, obj.Name)$
>>

JAVA_SIG_ArrayType(obj, name) ::= <<
//$obj.TypeName$ $name$$obj.ArrayDims:{d | [$d.TTString$]}$
16, $length(obj.ArrayDims)$, $obj.ArrayDims:{d | $d.Encoding$};separator=", "$
>>

JAVA_SIG_TypeDecl(obj, name) ::= <<
$dispatch("JAVA_SIG_", obj.Type, obj.name)$
>>

